# 오브젝트 1장: 객체, 설계

**조영호 저, "오브젝트: 코드로 이해하는 객체지향 설계" 1장 요약**

---

## 📚 1장의 목적

> **"변경에 강한 코드는 어떻게 설계되는가?"**

객체지향 프로그래밍은 **이론보다 실무가 먼저** 발전했습니다. 1장에서는 티켓 판매 애플리케이션을 단계적으로 개선하며 **좋은 설계**와 **나쁜 설계**의 차이를 직접 경험합니다.

---

## 🎫 티켓 판매 애플리케이션

### 요구사항
- 소극장에서 이벤트 당첨자에게 초대장 발송
- 초대장이 있으면 무료 입장, 없으면 티켓 구매
- 관람객은 가방에 초대장/현금/티켓 보관

### 클래스 구조
```
Theater (소극장)
  └─ enter(Audience)

TicketSeller (판매원)
  └─ TicketOffice (매표소)
       └─ Ticket, Cash

Audience (관람객)
  └─ Bag (가방)
       └─ Invitation, Cash, Ticket
```

---

## ❌ Step 01: 초기 설계의 문제점

### 절차지향적 코드
```java
public class Theater {
    public void enter(Audience audience) {
        if (audience.getBag().hasInvitation()) {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            audience.getBag().setTicket(ticket);
        } else {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            audience.getBag().minusAmount(ticket.getFee());
            ticketSeller.getTicketOffice().plusAmount(ticket.getFee());
            audience.getBag().setTicket(ticket);
        }
    }
}
```

### 로버트 마틴의 소프트웨어 모듈 3가지 기능

1. ✅ **제대로 실행되어야 한다** - 만족
2. ❌ **변경에 용이해야 한다** - 불만족
3. ❌ **이해하기 쉬워야 한다** - 불만족

### 구체적인 문제

| 문제 | 설명 |
|----|----|
| 상식에 어긋남 | Theater가 관람객 가방을 마음대로 열고, 판매원 없이 매표소 조작 |
| 높은 결합도 | Theater가 Audience, Bag, TicketSeller, TicketOffice 모두 의존 |
| 변경에 취약 | 관람객이 지갑을 사용하거나 신용카드 결제 시 Theater 수정 필요 |
| 낮은 재사용성 | 특정 상황에 강하게 의존 |

**Theater가 알아야 하는 것들:**
- Audience가 Bag을 가지고 있다
- Bag 안에 현금과 티켓이 들어있다
- TicketSeller가 TicketOffice에서 일한다
- TicketOffice에 돈과 티켓이 보관되어 있다

---

## ✅ Step 02: TicketSeller 자율성 부여

### 핵심 원칙
> **자율적인 객체를 만들자!**

### 개선 방법
**Before**: Theater가 TicketOffice에 직접 접근

**After**: TicketSeller가 스스로 티켓을 판매

```java
public class TicketSeller {
    private TicketOffice ticketOffice;

    public void sellTo(Audience audience) {
        ticketOffice.plusAmount(audience.buy(ticketOffice.getTicket()));
    }
}

public class Audience {
    private Bag bag;

    public Long buy(Ticket ticket) {
        if (bag.hasInvitation()) {
            bag.setTicket(ticket);
            return 0L;
        } else {
            bag.setTicket(ticket);
            bag.minusAmount(ticket.getFee());
            return ticket.getFee();
        }
    }
}

public class Theater {
    private TicketSeller ticketSeller;

    public void enter(Audience audience) {
        ticketSeller.sellTo(audience);  // 단순하게!
    }
}
```

### 개선 효과
- Theater는 TicketOffice를 모름
- TicketSeller는 Bag의 존재를 모름
- **책임 분리**: TicketSeller에게 판매 책임, Audience에게 구매 책임 부여
- **캡슐화**: 내부 구현을 외부로부터 숨김

---

## 🔑 Step 03: Bag 자율성 부여 (트레이드오프)

### 더 나아간 개선

```java
public class Bag {
    public Long hold(Ticket ticket) {
        if (hasInvitation()) {
            setTicket(ticket);
            return 0L;
        } else {
            setTicket(ticket);
            minusAmount(ticket.getFee());
            return ticket.getFee();
        }
    }

    // private으로 캡슐화
    private void setTicket(Ticket ticket) { ... }
    private boolean hasInvitation() { ... }
    private void minusAmount(Long amount) { ... }
}

public class Audience {
    public Long buy(Ticket ticket) {
        return bag.hold(ticket);  // Bag에게 위임
    }
}
```

### 설계의 트레이드오프
- 자율성을 무조건 높인다고 좋은 설계는 아님
- Bag이 스스로 결정하면 의인화가 과도해질 수 있음
- **설계는 상황에 맞는 균형의 문제**

---

## 🎯 개선 결과 비교

### 의존성 변화

**Before (절차지향)**:
```
Theater → Audience
       → Bag
       → TicketSeller
       → TicketOffice
       → Ticket
```

**After (객체지향)**:
```
Theater → TicketSeller → Audience → Bag
```

### 협력 방식 변화

**Before**:
```
Theater가 모든 것을 처리
  ↓
Audience, TicketSeller, Bag은 수동적 데이터
```

**After**:
```
각 객체가 자신의 데이터를 스스로 처리
  ↓
Theater → TicketSeller → Audience (메시지 전달)
```

---

## 💡 핵심 개념 정리

### 1. 캡슐화 (Encapsulation)
**정의**: 객체 내부의 세부사항을 감추는 것

**효과**:
- 변경을 객체 내부로 국한
- 외부 객체에 영향 최소화
- 낮은 결합도

### 2. 응집도 (Cohesion)
**정의**: 객체가 자신의 데이터를 스스로 처리하는 정도

**높은 응집도**:
- Audience가 자신의 Bag을 스스로 관리
- TicketSeller가 자신의 TicketOffice를 스스로 관리

### 3. 결합도 (Coupling)
**정의**: 객체 사이의 의존성 정도

- **높은 결합도**: 변경이 어려움
- **낮은 결합도**: 변경이 쉬움

### 4. 의존성 (Dependency)
**정의**: 어떤 객체가 변경될 때 다른 객체도 함께 변경될 가능성

**목표**: 최소한의 의존성만 유지

---

## 📊 절차지향 vs 객체지향

| 구분 | 절차지향 | 객체지향 |
|-----|---------|---------|
| **프로세스** | Theater.enter() | 각 객체의 메서드 |
| **데이터** | 수동적 구조 | 능동적 객체 |
| **특징** | 프로세스와 데이터 분리 | 데이터와 프로세스 결합 |
| **변경** | 여러 곳 수정 필요 | 해당 객체만 수정 |
| **책임** | 중앙 집중 | 분산 |

---

## 🤔 의인화 (Anthropomorphism)

### 현실 vs 객체지향

| 현실 세계 | 객체지향 세계 |
|----------|-------------|
| 가방은 스스로 돈을 꺼낼 수 없음 | Bag이 스스로 돈을 관리 |
| 매표소는 스스로 티켓을 판매할 수 없음 | TicketOffice가 스스로 판매 |

### 왜 의인화하는가?

> "모든 객체를 능동적이고 자율적인 존재로 취급한다"

- 설계를 단순하고 이해하기 쉽게 만들기 위함
- 변경에 유연하게 대응하기 위함
- 메시지 기반 협력 구조를 만들기 위함

---

## 📌 핵심 메시지

### 좋은 설계란?

1. **오늘 완성해야 하는 기능을 구현**하는 코드를 작성하는 동시에
2. **내일 쉽게 변경**할 수 있는 코드를 작성하는 것

### 객체지향 설계의 핵심

> **"객체에게 책임을 할당하고, 객체들이 협력하도록 만드는 것"**

| 원칙 | 의미 |
|-----|-----|
| 책임 분리 | 객체가 스스로 할 일을 하게 한다 |
| 캡슐화 | 내부 구현을 숨긴다 |
| 낮은 결합도 | 변경 영향 최소화 |
| 높은 응집도 | 명확한 역할 |
| 메시지 중심 | 객체 간 협력 강조 |

---

## 🎓 설계 개선 프로세스

1. **문제 인식**: 높은 결합도, 낮은 응집도 파악
2. **자율성 부여**: 객체가 스스로 처리하도록 책임 이동
3. **캡슐화**: 내부 구현 감추기
4. **의존성 제거**: 불필요한 연결 끊기

### 변경하기 쉬운 코드의 특징

✅ 각 객체가 자신의 데이터를 스스로 처리
✅ 객체 간 메시지로만 소통
✅ 최소한의 의존성
✅ 높은 응집도, 낮은 결합도

---

## 💬 토론 주제

1. **의인화**가 과도하면 오히려 이해하기 어려울 수 있을까?
2. 현실적으로 **모든 의존성을 제거**할 수 있을까?
3. **절차지향적 코드**가 더 적합한 경우도 있을까?

---

## 📖 참고자료

- 조영호, "오브젝트: 코드로 이해하는 객체지향 설계", 위키북스
- 로버트 마틴, "클린 소프트웨어"
