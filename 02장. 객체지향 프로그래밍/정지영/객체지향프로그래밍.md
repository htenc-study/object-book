# 02 객체지향 프로그래밍

## 01. 영화 예매 시스템

`영화`: 영화에 대한 기본 정보
    - 제목, 상영시간, 가격 정보
`상영`: 실제로 관객들이 영화를 관람하는 사건
    - 상영 일자, 시간, 순번
`할인 조건`
    - 순서조건: 상영 순번을 이용해 할인 여부 결정(상영 순번과 연관)
    - 기간조건: 요일, 시작시간, 종료시간 (상영시간 및 일자와 연관)
`할인 정책`: 각 영화마다 적용되는 할인 정책이 다름
    - 금액할인정책, 비율할인정책, 정책 없음

`고객`
`예매`

## 02. 객체지향 프로그래밍을 향해

```
진정한 객체지향 패러다임으로의 전환은 Class가 아닌, Object에 초점을 맞출 때에만 얻을 수 있다.
```

1. 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민하라.
2. 객체를 독립적인 존재가 아니라, 기능 구현을 위해 협력하는 공동체의 일원으로 봐야한다.


`도메인`: 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야
- 객체지향 패러다임이 강력한 이유는 요구사항을 분석하는 초기 단계부터, 프로그램을 구현하는 마지막 단계까지 객체라는 동일한 추상화 기법을 사용할 수 있기 때문이다. <br>
요구사항과 프로그램을 객체라는 동일한 관점에서 보기 때문에 도메인을 구성하는 개념들이 프로그램의 객체와 클래스로 매끄럽게 연결된다.

`객체`
1. 객체는 상태(state)와 행동(behavior)을 함께 가지는 복합적인 존재라는 것
2. 객체는 스스로 판단하고 행동하는 자율적인 존재이다.
- 접근 수정자를 통해 객체 내부에 대한 접근을 제어하는 이유는 객체를 자율적인 존재로 만들기 위해서.

`캡슐화`: 데이터와 기능을 객체 내부로 묶는 것
- 외부에서 접근 가능한 부분 public interface
- 내부에서 접근 가능한 부분 implementation(구현)

`협력`: 시스템의 어떤 기능을 구현하기 위해 객체들 사이에서 이뤄지는 상호작용
- 객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메시지를 전송하는 것 분이다.
- 메시지를 처리하기 위한 자신만의 방법을 메서드라고 부른다.
- 메시지와 메서드를 구분에서부터 다형성의 개념이 출발

ex)
 
- 메시지: discountPolicy.calculateDiscountAmount(screening)
- 메서드: DefaultDiscountPolicy 클래스의 claculateDsciountAmount 
  
  

## 03. 할인 요금 구하기
``` java
public abstract class DiscountPolicy {
    private List<DiscountCondition> conditions = new ArrayList<>();

    public DiscountPolicy(DiscountCondition ... conditions) {
        this.conditions = Arrays.asList(conditions);
    }

    public Money calculateDisCountAmount(Screening screening) {
        for (DiscountCondition each : conditions) {
            if (each.isSatisfiedBy(screening)) {
                return getDiscountAmount(screening);
            }
        }

        return Money.ZERO;
    }

    abstract protected Money getDiscountAmount(Screening screening);
}

 public class Movie {
      private String title;
      private Duration runningTime;
      private Money fee;
      private DiscountPolicy discountPolicy;

      public Movie(String title, Duration runningTime, Money fee, DiscountPolicy discountPolicy) {
          this.title = title;
          this.runningTime = runningTime;
          this.fee = fee;
          this.discountPolicy = discountPolicy;
      }

      public Money getFee() {
          return fee;
      }

      public Money calculateMovieFee(Screening screening){
          return fee.minus(discountPolicy.calculateDiscountAmount(screening))
      }
  }

  public class Main {
    public static void main(String[] args) {
      DiscountPolicy policy = new AmountDiscountPolicy(Money.wons(800),
        new SequenceCondition(1),
        new SequenceCondition(10),
        new PeriodCondition(DayOfWeek.MONDAY, LocalTime.of(10,0),LocalTime.of(11,59)),
        new PeriodCondition(DayOfWeek.THURSDAY, LocalTime.of(10,0),LocalTime.of(20,59))
    );

      Movie avatar = new Movie("아바타", Duration.ofMinutes(120), Money.wons(10000), policy);

      Screening first = new Screening(avatar, 1, LocalDateTime.now().withHour(10).withMinute(30));

      Reservation r = first.reserve(new Customer("id-1572350", "홍길동"), 3);
      System.out.println("예매 완료: " + r);
    }
  }
```

- 상속과 다형성, 추상화

`추상클래스`
- 상위 클래스인 DiscountPolicy 안에 중복 코드를 두고, AmountDiscountPolicy, PercentDiscountPolicy가 이 클래스를 상속.
- getDiscountAmount는 추상메서드로 선언하여 하위 클래스에 위임

`다형성`
- Movie객체에서 확인 했을 때, 어떤 할인 정책이 적용되는지 알 수 없다.
- Main에서 AmountDiscountPolicy 또는 PercentDiscountPolicy를 넣을 수 있다.

`TEMPLATE METHOD 패턴`
- 기본적인 알고리즘의 흐름을 결정하고, 중간에 필요한 처리를 하위 클래스에게 위임하는 디자인 패턴


## 04. 상속과 다형성
![DiscountPolicy 상속계층](의존성.png)
- 코드의 의존성과 실행시점의 의존성이 서로 다를 수 있다.
- 코드의 의존성은 Movie -> DiscountPolicy이지만,
- 실행시점의 의존성은 Movie -> AmountDiscountPolicy이다.
- 트레이드오프: 유연한 설계가 되는 대신, 코드를 이해하고 디버깅하기 어려워질 수 있다.

```
상속은 그저 부모 클래스의 것을 물려받는 것이 아니다.
상속의 핵심은 "확장"에 있다.
```
`업캐스팅`: 자식 클래스가 부모 클래스를 대신하는 것.
- 자식클래스는 상속을 통해서 부모 클래스의 인터페이스를 물려받기 때문에 부모 클래스 대신 사용할 수 있다.
- 컴파일러는 코드 상에서 부모클래스가 나오는 모든 장소에서 자식 클래스를 사용하는 것을 허용한다.

`다형성`
- 동일한 메시지를 전송하지만 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇인가에 따라 달라진다.
- 다형성은 객체지향 프로그래밍의 컴파일 시간 의존성과 실행시간 의존성이 다를 수 있다는 사실을 기반으로 한다.
- 동일한 메시지를 수신했을 때, 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미한다.
- 지연바인딩 or 동적바인딩: 메시지와 메서드를 실행시점에 바인딩
- 초기바인딩 or 정적바인딩: 전통적인 함수 호출처럼 컴파일 시점에 함수나 프로시저를 결정하는 것.



## 05. 추상화와 유연성
`추상화의 장점`
1. 추상화의 계층만 따로 떼어 놓고 살펴보면 요구사항의 정책을 높은 수준에서 서술할 수 있다.
- 추상화를 이용해 상위 정책을 기술한다는 것은 기본적인 애플리케이션의 협력 흐름을 기술한다는 것을 의미.
- 자식 클래스들은 추상화를 이용해서 정의한 상위의 협력 흐름을 그대로 따르게 된다.
- 디자인패턴, 프레임워크 모두 추상화를 이용해 상위정책을 정의
2. 기존 구조를 수정하지 않고도 새로운 기능을 쉽게 추가하고 확장할 수 있다.


`상속의 문제점`
1. 캡슐화 위반
- 상속을 이용하면 부모 클래스의 내부 구조를 자식 클래스가 잘 알고 있어야한다.

2. 설계가 유연해지지 않는다.
- 상속은 부모클래스와 자식클래스의 관계를 컴파일 시점에 결정하기 때문에, 실행 시점에서 객체의 종류를 변경하는 것이 불가능해진다.

`합성`
- 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법

1. 인터페이스에 정의된 메시지를 통해서만 재사용이 가능하기 때문에 구현을 효과적으로 캡슐화할 수 있다.
2. 사용하는 인스턴스를 교체하는 작업만으로도 손쉽게 설계를 유연하게 만들 수 있는 것


- 다형성을 위해서 인터페이스를 재사용하는 경우 합성과 상속을 동시에 사용할 수 밖에 없다.
- 프로그래밍 관점에 너무 치우쳐서 객체지향을 바라볼 경우 객체지향의 본질을 놓치기 쉽다.
- 객체지향에서 가장 중요한 것은 애플리케이션의 기능을 구현하기 위해 협력에 참여하는 객체들 사이의 상호작용이다.​
- 객체들은 협력에 참여하기 위해 역할을 부여받고 역할에 적합한 책임을 수행한다.
- 즉, 적절한 협력을 식별하고 협력에 필요한 역할을 정의한 후에 역할을 수행할 수 있는 적절한 객체에 적절한 책임을 할당하는 것이다.


